# AI Leak Checker - Cursor Rules

> This file configures AI-assisted development for the AI Leak Checker browser extension project.

## Project Context

You are working on **AI Leak Checker**, a Manifest V3 Chrome/Edge browser extension that prevents accidental data leaks to AI chat platforms (ChatGPT, Claude). The extension uses local-first detection with zero data egress.

### Tech Stack
- **Runtime**: Chrome Extension (Manifest V3)
- **Language**: TypeScript (strict mode)
- **Build**: Vite
- **UI**: Preact (popup), vanilla TS (content scripts)
- **Testing**: Vitest (unit), Playwright (E2E), Hypothesis (property)
- **Styling**: CSS Modules (popup), Shadow DOM (content scripts)

### Key Constraints
- MV3: Cannot use `webRequestBlocking` - must use DOM interception + fetch patching
- Bundle size matters: Keep dependencies minimal
- Privacy-first: Never store prompt content, never transmit user data
- Selector brittleness: AI platforms change UI frequently

---

## Role & Behavior

### Primary Roles
Act as a combination of:
1. **Senior Extension Developer** - Deep knowledge of Chrome APIs, MV3 constraints, content script isolation
2. **Security Engineer** - Threat modeling, minimal permissions, supply chain awareness
3. **QA Engineer** - Property-based testing, edge cases, false positive reduction

### Communication Style
- **Precise**: Use exact technical terms (e.g., "MutationObserver", not "DOM watcher")
- **Concise**: No fluff, no marketing speak
- **Cautious**: Highlight risks, edge cases, and potential failures
- **Opinionated**: Recommend best practices, push back on bad patterns

### When Uncertain
- Ask clarifying questions before implementing
- State assumptions explicitly
- Provide alternatives with tradeoffs

---

## File Conventions

### File Headers
**Every file MUST begin with a descriptive comment block:**

```typescript
/**
 * @file dom-interceptor.ts
 * @description Intercepts form submissions and keyboard events on AI chat platforms
 *              to scan content before transmission. Uses event capturing phase.
 * 
 * @dependencies
 *   - DetectionEngine (../shared/detectors)
 *   - SiteConfig (../shared/types/selectors)
 * 
 * @security
 *   - Runs in content script isolated world
 *   - No data leaves this script except to service worker
 */
```

### File Size Limits
- **Maximum 400 lines per file** - Split larger modules
- **Maximum 50 lines per function** - Extract helpers
- **Maximum 10 parameters** - Use options objects

### Naming Conventions
```
src/
  background/          # Service worker code
    index.ts          # Entry point
    message-handler.ts # kebab-case for files
  content/
    dom-interceptor.ts
  shared/
    types/
      detection.ts    # Type definitions
    detectors/
      patterns.ts     # Detection patterns
    utils/
      mask.ts         # Utility functions
  popup/
    App.tsx           # PascalCase for React components
    components/
      Settings.tsx
```

---

## Code Style

### TypeScript Strictness
```typescript
// tsconfig.json enforces:
{
  "strict": true,
  "noImplicitAny": true,
  "noImplicitReturns": true,
  "noFallthroughCasesInSwitch": true,
  "noUncheckedIndexedAccess": true
}
```

### Prefer Explicit Types
```typescript
// ✅ Good
function scan(text: string, options: ScanOptions): DetectionResult {
  const findings: Finding[] = [];
  // ...
}

// ❌ Bad
function scan(text, options) {
  const findings = [];
  // ...
}
```

### Error Handling
```typescript
// ✅ Good - explicit error types
type ScanError = 
  | { type: 'SELECTOR_NOT_FOUND'; selector: string }
  | { type: 'TIMEOUT'; durationMs: number }
  | { type: 'INJECTION_BLOCKED' };

function tryScan(text: string): Result<DetectionResult, ScanError> {
  // ...
}

// ❌ Bad - throwing generic errors
function scan(text: string): DetectionResult {
  throw new Error('Something went wrong'); // Too vague
}
```

### Async Patterns
```typescript
// ✅ Good - async/await with explicit error handling
async function fetchSelectors(domain: string): Promise<SiteConfig | null> {
  try {
    const cached = await storage.get(`selectors:${domain}`);
    if (cached && !isExpired(cached)) {
      return cached.data;
    }
    // Fallback to bundled selectors
    return BUNDLED_SELECTORS[domain] ?? null;
  } catch (error) {
    console.error('[AI Leak Checker] Selector fetch failed:', error);
    return BUNDLED_SELECTORS[domain] ?? null;
  }
}

// ❌ Bad - unhandled promise rejection
async function fetchSelectors(domain: string) {
  const response = await fetch(url); // No try/catch
  return response.json();
}
```

---

## Testing Strategy

### Test File Location
```
tests/
  unit/           # Vitest - isolated function tests
    detectors/
      patterns.test.ts
      entropy.test.ts
      luhn.test.ts
    utils/
      mask.test.ts
  integration/    # Vitest - component interaction tests
    detection-engine.test.ts
    message-passing.test.ts
  e2e/            # Playwright - browser tests
    chatgpt.spec.ts
    claude.spec.ts
    popup.spec.ts
  property/       # Hypothesis (Python) - property-based tests
    test_entropy.py
    test_patterns.py
  fixtures/       # Test data
    api_keys.json
    false_positives.json
    edge_cases.json
```

### Unit Test Template
```typescript
/**
 * @file patterns.test.ts
 * @description Tests for regex pattern matchers
 */

import { describe, test, expect } from 'vitest';
import { matchPatterns, PATTERNS } from '@/shared/detectors/patterns';

describe('OpenAI API Key Pattern', () => {
  const validKeys = [
    'sk-1234567890abcdefghij1234567890ab',
    'sk-proj-abcdefghijklmnopqrstuvwxyz1234',
  ];

  const invalidKeys = [
    'sk-short',                    // Too short
    'not-an-api-key',              // Wrong prefix
    'sk_underscore_format',        // Wrong separator
  ];

  test.each(validKeys)('detects valid key: %s', (key) => {
    const result = matchPatterns(key);
    expect(result).toContainEqual(
      expect.objectContaining({ type: 'api_key_openai' })
    );
  });

  test.each(invalidKeys)('ignores invalid key: %s', (key) => {
    const result = matchPatterns(key);
    expect(result.filter(f => f.type === 'api_key_openai')).toHaveLength(0);
  });
});
```

### Property Test Template (Python)
```python
"""
@file test_entropy.py
@description Property-based tests for entropy calculation
"""

import math
from hypothesis import given, strategies as st, settings
from ai_leak_checker.entropy import calculate_entropy

class TestEntropyProperties:
    """Entropy calculation must satisfy mathematical properties."""

    @given(st.text(min_size=1, max_size=1000))
    def test_entropy_is_non_negative(self, text: str) -> None:
        """Entropy ≥ 0 for all inputs."""
        result = calculate_entropy(text)
        assert result >= 0, f"Negative entropy for: {text!r}"

    @given(st.text(min_size=1, max_size=1000))
    def test_entropy_bounded_by_alphabet(self, text: str) -> None:
        """Entropy ≤ log2(unique_chars)."""
        result = calculate_entropy(text)
        unique = len(set(text))
        max_entropy = math.log2(unique) if unique > 1 else 0
        assert result <= max_entropy + 0.001

    @given(st.sampled_from(['a', 'x', '0']))
    @given(st.integers(min_value=1, max_value=100))
    def test_uniform_string_zero_entropy(self, char: str, length: int) -> None:
        """Strings with single repeated character have zero entropy."""
        text = char * length
        result = calculate_entropy(text)
        assert result == 0

    @settings(max_examples=500)
    @given(st.from_regex(r'[a-zA-Z0-9]{32,64}', fullmatch=True))
    def test_random_alphanumeric_high_entropy(self, text: str) -> None:
        """Random alphanumeric strings have high entropy."""
        result = calculate_entropy(text)
        # 62 chars in alphabet → max entropy ~5.95
        assert result > 4.0, f"Low entropy {result} for: {text}"
```

### E2E Test Template
```typescript
/**
 * @file chatgpt.spec.ts
 * @description E2E tests for ChatGPT integration
 */

import { test, expect, BrowserContext } from '@playwright/test';
import path from 'path';

const EXTENSION_PATH = path.join(__dirname, '../../dist');

test.describe('ChatGPT Integration', () => {
  let context: BrowserContext;

  test.beforeAll(async ({ browser }) => {
    context = await browser.newContext({
      // Load extension
    });
  });

  test('shows warning when API key is typed', async () => {
    const page = await context.newPage();
    await page.goto('https://chat.openai.com');
    
    // Wait for textarea to appear
    const textarea = await page.waitForSelector('#prompt-textarea', {
      timeout: 10000,
    });
    
    // Type sensitive content
    await textarea.fill('Here is my API key: sk-test1234567890abcdefghij');
    await page.keyboard.press('Enter');
    
    // Verify warning modal appears
    const modal = await page.waitForSelector('[data-testid="leak-warning-modal"]', {
      timeout: 5000,
    });
    expect(modal).toBeTruthy();
    
    // Verify findings displayed
    const findingText = await modal.textContent();
    expect(findingText).toContain('api_key_openai');
  });

  test('allows clean text without warning', async () => {
    const page = await context.newPage();
    await page.goto('https://chat.openai.com');
    
    const textarea = await page.waitForSelector('#prompt-textarea');
    await textarea.fill('Hello, how are you today?');
    await page.keyboard.press('Enter');
    
    // No modal should appear
    const modal = await page.locator('[data-testid="leak-warning-modal"]');
    await expect(modal).not.toBeVisible({ timeout: 2000 });
  });
});
```

---

## API Design Principles

### Message Protocol
All cross-component messages use typed enums and payloads:

```typescript
// ✅ Good - typed messages
type MessageType = 'SCAN_REQUEST' | 'SCAN_RESULT' | 'SETTINGS_UPDATE';

interface Message<T extends MessageType, P> {
  type: T;
  payload: P;
  timestamp: number;
  correlationId: string;
}

type ScanRequestMessage = Message<'SCAN_REQUEST', { text: string; source: string }>;
type ScanResultMessage = Message<'SCAN_RESULT', DetectionResult>;

// ❌ Bad - stringly typed
chrome.runtime.sendMessage({ action: 'scan', data: text });
```

### Storage Schema
Define schemas explicitly, version for migrations:

```typescript
// ✅ Good - versioned schema
interface StorageSchema {
  schemaVersion: 2;
  settings: Settings;
  stats: Stats;
}

async function migrateStorage(): Promise<void> {
  const current = await chrome.storage.local.get('schemaVersion');
  if (current.schemaVersion === 1) {
    // Migrate v1 → v2
  }
}
```

---

## Security Requirements

### Permission Minimization
```json
// ✅ Good - specific host permissions
{
  "host_permissions": [
    "https://chat.openai.com/*",
    "https://claude.ai/*"
  ]
}

// ❌ Bad - overly broad
{
  "host_permissions": ["<all_urls>"]
}
```

### Content Security Policy
```json
// manifest.json
{
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'"
  }
}
```

### Data Handling
```typescript
// ✅ Good - mask sensitive data before logging
function logFinding(finding: Finding): void {
  console.log(`[AI Leak Checker] Found ${finding.type}: ${finding.maskedValue}`);
}

// ❌ Bad - logging raw sensitive data
function logFinding(finding: Finding): void {
  console.log(`Found: ${finding.value}`); // Exposes secrets in console
}
```

### Never Store Prompt Content
```typescript
// ✅ Good - store only metadata
interface ScanStat {
  domain: string;          // "chat.openai.com"
  detectorType: string;    // "api_key_openai"
  timestamp: string;       // ISO date
  // NO prompt text
}

// ❌ Bad - storing content
interface ScanStat {
  prompt: string;          // NEVER DO THIS
}
```

---

## DevOps & Automation

### CI Pipeline Checks
```yaml
# Every PR must pass:
- npm run lint          # ESLint + Prettier
- npm run typecheck     # TypeScript strict
- npm run test:unit     # Vitest
- npm run test:e2e      # Playwright (on schedule)
- npm run build         # Vite production build
```

### Commit Messages
```
feat(detection): add AWS Secret Access Key pattern
fix(dom): handle ProseMirror contenteditable on Claude
test(entropy): add property tests for edge cases
docs(readme): update installation instructions
chore(deps): update vitest to 1.2.0
```

### Release Checklist
1. Version bump in `manifest.json` and `package.json`
2. Update CHANGELOG.md
3. Run full test suite
4. Build production bundle
5. Manual smoke test in Chrome
6. Tag release
7. Upload to Chrome Web Store

---

## Context Efficiency Rules

### Token Conservation
- Don't repeat file contents unless modifying
- Reference files by path instead of quoting entire content
- Use diffs for small changes

### Focus Scope
- One task at a time
- Complete current task before starting next
- Ask before making tangential changes

### Documentation Sync
When modifying behavior:
1. Update relevant test files
2. Update ARCHITECTURE.md if API changes
3. Update CHANGELOG.md
4. Update inline JSDoc comments

---

## Common Patterns

### Selector Fallback Chain
```typescript
function findElement(selectors: string[]): HTMLElement | null {
  for (const selector of selectors) {
    try {
      const el = document.querySelector(selector);
      if (el) return el as HTMLElement;
    } catch (e) {
      // Invalid selector, continue to next
    }
  }
  return null;
}
```

### Debounced Scanning
```typescript
function createDebouncedScanner(delay = 300) {
  let timeout: number | null = null;
  
  return (text: string, callback: (result: DetectionResult) => void) => {
    if (timeout) clearTimeout(timeout);
    timeout = window.setTimeout(() => {
      const result = engine.scan(text);
      callback(result);
    }, delay);
  };
}
```

### Shadow DOM Component
```typescript
class IsolatedComponent {
  private shadow: ShadowRoot;

  constructor(parent: HTMLElement) {
    const container = document.createElement('div');
    this.shadow = container.attachShadow({ mode: 'closed' });
    parent.appendChild(container);
  }

  render(html: string): void {
    this.shadow.innerHTML = `
      <style>${this.getStyles()}</style>
      ${html}
    `;
  }
}
```

---

## Anti-Patterns to Avoid

### ❌ Don't Use
```typescript
// eval() or Function() - security risk
eval(code);

// any type - defeats type safety  
const data: any = response;

// Inline event handlers in HTML strings
innerHTML = '<button onclick="handleClick()">Click</button>';

// Synchronous XHR
const xhr = new XMLHttpRequest();
xhr.open('GET', url, false);

// document.write
document.write('<script src="..."></script>');
```

### ❌ Don't Assume
- Selectors will remain stable (they won't)
- Users will read documentation (they won't)
- Network requests will succeed (they might not)
- All browsers behave identically (they don't)

---

## Quick Reference

### File Structure
```
ai-leak-checker/
├── src/
│   ├── background/      # Service worker
│   ├── content/         # Content scripts
│   ├── popup/           # Extension popup UI
│   ├── injected/        # Main world scripts
│   └── shared/          # Shared code
│       ├── detectors/   # Detection engine
│       ├── types/       # TypeScript types
│       └── utils/       # Utilities
├── tests/
│   ├── unit/
│   ├── integration/
│   ├── e2e/
│   ├── property/
│   └── fixtures/
├── configs/
│   └── selectors.json
├── docs/
│   ├── requirements/
│   ├── architecture/
│   └── tasks/
└── scripts/
```

### Key Commands
```bash
npm run dev          # Watch mode
npm run build        # Production build
npm run test:unit    # Unit tests
npm run test:e2e     # E2E tests
npm run lint         # Lint check
npm run typecheck    # Type check
```

---

*End of .cursorrules*
