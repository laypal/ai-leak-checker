---
description: TypeScript code style, conventions, and patterns for the AI Leak Checker project.
globs:
alwaysApply: true
---

# Code Style & Conventions

## TypeScript Requirements

### Strict Mode Enforced

```typescript
// tsconfig.json enforces all of these
{
  "strict": true,
  "noImplicitAny": true,
  "noImplicitReturns": true,
  "noFallthroughCasesInSwitch": true,
  "noUncheckedIndexedAccess": true
}
```

### Always Use Explicit Types

```typescript
// ✅ Correct
function scan(text: string, options: ScanOptions): DetectionResult {
  const findings: Finding[] = [];
  // ...
}

// ❌ Wrong - implicit any
function scan(text, options) {
  const findings = [];
}
```

### Error Handling Pattern

```typescript
// ✅ Correct - typed errors with Result pattern
type ScanError = 
  | { type: 'SELECTOR_NOT_FOUND'; selector: string }
  | { type: 'TIMEOUT'; durationMs: number }
  | { type: 'INJECTION_BLOCKED' };

function tryScan(text: string): Result<DetectionResult, ScanError> {
  // ...
}

// ❌ Wrong - generic throws
throw new Error('Something went wrong');
```

### Async Patterns

```typescript
// ✅ Correct - explicit error handling with fallback
async function fetchSelectors(domain: string): Promise<SiteConfig | null> {
  try {
    const cached = await storage.get(`selectors:${domain}`);
    if (cached && !isExpired(cached)) return cached.data;
    return BUNDLED_SELECTORS[domain] ?? null;
  } catch (error) {
    console.error('[AI Leak Checker] Selector fetch failed:', error);
    return BUNDLED_SELECTORS[domain] ?? null;
  }
}

// ❌ Wrong - unhandled rejection
async function fetchSelectors(domain: string) {
  const response = await fetch(url); // No try/catch
  return response.json();
}
```

## File Conventions

### Size Limits

- **Max 400 lines per file** - Split larger modules
- **Max 50 lines per function** - Extract helpers
- **Max 10 parameters** - Use options objects

### File Header Template

Every file must begin with:

```typescript
/**
 * @file dom-interceptor.ts
 * @description Intercepts form submissions on AI chat platforms.
 * 
 * @dependencies
 *   - DetectionEngine (../shared/detectors)
 *   - SiteConfig (../shared/types/selectors)
 * 
 * @security
 *   - Runs in content script isolated world
 *   - No data leaves except to service worker
 */
```

### Naming

| Type | Convention | Example |
|------|------------|---------|
| Files | kebab-case | `dom-interceptor.ts` |
| React/Preact | PascalCase | `Settings.tsx` |
| Functions | camelCase | `scanForSecrets()` |
| Constants | UPPER_SNAKE | `MAX_SCAN_LENGTH` |
| Types/Interfaces | PascalCase | `DetectionResult` |
| Enum values | UPPER_SNAKE | `DetectorType.API_KEY_OPENAI` |

## Common Patterns

### Selector Fallback Chain

```typescript
function findElement(selectors: string[]): HTMLElement | null {
  for (const selector of selectors) {
    try {
      const el = document.querySelector(selector);
      if (el) return el as HTMLElement;
    } catch {
      // Invalid selector, continue
    }
  }
  return null;
}
```

### Debounced Scanning

```typescript
function createDebouncedScanner(delay = 300) {
  let timeout: number | null = null;
  
  return (text: string, callback: (result: DetectionResult) => void) => {
    if (timeout) clearTimeout(timeout);
    timeout = window.setTimeout(() => {
      callback(engine.scan(text));
    }, delay);
  };
}
```

### Message Protocol

```typescript
// ✅ Correct - typed messages
type MessageType = 'SCAN_REQUEST' | 'SCAN_RESULT' | 'SETTINGS_UPDATE';

interface Message<T extends MessageType, P> {
  type: T;
  payload: P;
  timestamp: number;
}

// ❌ Wrong - stringly typed
chrome.runtime.sendMessage({ action: 'scan', data: text });
```

## Anti-Patterns to Avoid

```typescript
// ❌ Never use
eval(code);                    // Security risk
const data: any = response;    // Defeats type safety
innerHTML = '<button onclick="fn()">'; // XSS vector
xhr.open('GET', url, false);   // Synchronous XHR
document.write('<script>');    // Breaks page
```
